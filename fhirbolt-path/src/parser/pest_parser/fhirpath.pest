// This is a line-by-line translation of the provided ANTLR4 grammar.

// grammar fhirpath;

// // Grammar rules
// // [FHIRPath](http://hl7.org/fhirpath/N1) Normative Release

// //prog: line (line)*;
// //line: ID ( '(' expr ')') ':' expr '\r'? '\n';
start = { expression ~ EOI }

// expression
// : term                                                      #termExpression
// | expression '.' invocation                                 #invocationExpression
// | expression '[' expression ']'                             #indexerExpression
// | ('+' | '-') expression                                    #polarityExpression
// | expression ('*' | '/' | 'div' | 'mod') expression         #multiplicativeExpression
// | expression ('+' | '-' | '&') expression                   #additiveExpression
// | expression ('is' | 'as') typeSpecifier                    #typeExpression
// | expression '|' expression                                 #unionExpression
// | expression ('<=' | '<' | '>' | '>=') expression           #inequalityExpression
// | expression ('=' | '~' | '!=' | '!~') expression           #equalityExpression
// | expression ('in' | 'contains') expression                 #membershipExpression
// | expression 'and' expression                               #andExpression
// | expression ('or' | 'xor') expression                      #orExpression
// | expression 'implies' expression                           #impliesExpression
// //| (IDENTIFIER)? '=>' expression                             #lambdaExpression
// ;
expression               = { impliesExpression }
impliesExpression        = { orExpression ~ (impliesOp ~ expression)* }
orExpression             = { andExpression ~ (orOp ~ expression)* }
andExpression            = { membershipExpression ~ ("and" ~ expression)* }
membershipExpression     = { equalityExpression ~ (membershipOp ~ expression)* }
equalityExpression       = { inequalityExpression ~ (equalityOp ~ expression)* }
inequalityExpression     = { unionExpression ~ (inequalityOp ~ expression)* }
unionExpression          = { typeExpression ~ ("|" ~ expression)* }
typeExpression           = { additiveExpression ~ (typeOp ~ typeSpecifier)* }
additiveExpression       = { multiplicativeExpression ~ (additiveOp ~ expression)* }
multiplicativeExpression = { polarityExpression ~ (multiplicativeOp ~ expression)* }
polarityExpression       = { polarityOp? ~ indexerExpression }
indexerExpression        = { invocationExpression ~ ("[" ~ expression ~ "]")* }
invocationExpression     = { termExpression ~ ("." ~ invocation)* }
termExpression           = { term }

impliesOp        = { "implies" }
orOp             = { "or" | "xor" }
membershipOp     = { "in" | "contains" }
equalityOp       = { "=" | "~" | "!=" | "!~" }
inequalityOp     = { "<=" | "<" | ">" | ">=" }
typeOp           = { "is" | "as" }
additiveOp       = { "+" | "-" | "&" }
multiplicativeOp = { "*" | "/" | "div" | "mod" }
polarityOp       = { "+" | "-" }

// term
// : invocation                                            #invocationTerm
// | literal                                               #literalTerm
// | externalConstant                                      #externalConstantTerm
// | '(' expression ')'                                    #parenthesizedTerm
// ;
term = { invocation | literal | externalConstant | "(" ~ expression ~ ")" }

// literal
// : '{' '}'                                               #nullLiteral
// | ('true' | 'false')                                    #booleanLiteral
// | STRING                                                #stringLiteral
// | NUMBER                                                #numberLiteral
// | DATE                                                  #dateLiteral
// | DATETIME                                              #dateTimeLiteral
// | TIME                                                  #timeLiteral
// | quantity                                              #quantityLiteral
// ;
literal = { "{" ~ "}" | BOOL | STRING | NUMBER | DATE | DATETIME | TIME | quantity }

// externalConstant
// : '%' ( identifier | STRING )
// ;
externalConstant = @{ "%" ~ (identifier | STRING) }

// invocation                          // Terms that can be used after the function/member invocation '.'
// : identifier                                            #memberInvocation
// | function                                              #functionInvocation
// | '$this'                                               #thisInvocation
// | '$index'                                              #indexInvocation
// | '$total'                                              #totalInvocation
// ;
invocation      = { function | identifier | thisInvocation | indexInvocation | totalInvocation }
thisInvocation  = { "$this" }
indexInvocation = { "$index" }
totalInvocation = { "$total" }

// function
// : identifier '(' paramList? ')'
// ;
function = { identifier ~ "(" ~ paramList? ~ ")" }

// paramList
// : expression (',' expression)*
// ;
paramList = { expression ~ ("," ~ expression)* }

// quantity
// : NUMBER unit?
// ;
quantity = { NUMBER ~ unit }

// unit
// : dateTimePrecision
// | pluralDateTimePrecision
// | STRING // UCUM syntax for units of measure
// ;
unit = { dateTimePrecision | pluralDateTimePrecision | STRING }

// dateTimePrecision
// : 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond'
// ;
dateTimePrecision = { "year" | "month" | "week" | "day" | "hour" | "minute" | "second" | "millisecond" }

// pluralDateTimePrecision
// : 'years' | 'months' | 'weeks' | 'days' | 'hours' | 'minutes' | 'seconds' | 'milliseconds'
// ;
pluralDateTimePrecision = { "years" | "months" | "weeks" | "days" | "hours" | "minutes" | "seconds" | "milliseconds" }

// typeSpecifier
// : qualifiedIdentifier
// ;
typeSpecifier = { qualifiedIdentifier }

// qualifiedIdentifier
// : identifier ('.' identifier)*
// ;
qualifiedIdentifier = { identifier ~ ("." ~ identifier)* }

// identifier
// : IDENTIFIER
// | DELIMITEDIDENTIFIER
// | 'as'
// | 'contains'
// | 'in'
// | 'is'
// ;

identifier = @{ IDENTIFIER | DELIMITEDIDENTIFIER | "as" | "contains" | "in" | "is" }

// /****************************************************************
// Lexical rules
// *****************************************************************/
// 
// /*
// NOTE: The goal of these rules in the grammar is to provide a date
// token to the parser. As such it is not attempting to validate that
// the date is a correct date, that task is for the parser or interpreter.
// */

// DATE
// : '@' DATEFORMAT
// ;
DATE = @{ "@" ~ DATEFORMAT }

// DATETIME
// : '@' DATEFORMAT 'T' (TIMEFORMAT TIMEZONEOFFSETFORMAT?)?
// ;
DATETIME = @{ "@" ~ DATEFORMAT ~ "T" ~ (TIMEFORMAT ~ TIMEZONEOFFSETFORMAT?)? }

// TIME
// : '@' 'T' TIMEFORMAT
// ;
TIME = @{ "@" ~ "T" ~ TIMEFORMAT }

// fragment DATEFORMAT
// : [0-9][0-9][0-9][0-9] ('-'[0-9][0-9] ('-'[0-9][0-9])?)?
// ;
DATEFORMAT = @{ ASCII_DIGIT{4} ~ ("-" ~ ASCII_DIGIT{2} ~ ("-" ~ ASCII_DIGIT{2})?)? }

// fragment TIMEFORMAT
// : [0-9][0-9] (':'[0-9][0-9] (':'[0-9][0-9] ('.'[0-9]+)?)?)?
// ;
TIMEFORMAT = @{ ASCII_DIGIT{2} ~ (":" ~ ASCII_DIGIT{2} ~ (":" ~ ASCII_DIGIT{2})? ~ (":" ~ ASCII_DIGIT{2})?)? }

// fragment TIMEZONEOFFSETFORMAT
// : ('Z' | ('+' | '-') [0-9][0-9]':'[0-9][0-9])
// ;
TIMEZONEOFFSETFORMAT = @{ "Z" | ("+" | "-") ~ ASCII_DIGIT{2} ~ ":" ~ ASCII_DIGIT{2} }

// IDENTIFIER
// : ([A-Za-z] | '_')([A-Za-z0-9] | '_')*            // Added _ to support CQL (FHIR could constrain it out)
// ;
IDENTIFIER = @{ (ASCII_ALPHA | "_") ~ ASCII_ALPHANUMERIC* }

// DELIMITEDIDENTIFIER
// : '`' (ESC | .)*? '`'
// ;
DELIMITEDIDENTIFIER = @{ "`" ~ (ESC | !"`" ~ ANY)* ~ "`" }

BOOL = @{ "true" | "false" }

// STRING
// : '\'' (ESC | .)*? '\''
// ;
STRING = @{ "'" ~ (ESC | !"'" ~ ANY)* ~ "'" }

// // Also allows leading zeroes now (just like CQL and XSD)
// NUMBER
// : [0-9]+('.' [0-9]+)?
// ;
NUMBER = @{ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT)? }

// // Pipe whitespace to the HIDDEN channel to support retrieving source text through the parser.
// WS
// : [ \r\n\t]+ -> channel(HIDDEN)
// ;
WHITESPACE = _{ " " | "\r" | "\n" | "\t" }

// COMMENT
// : '/*' .*? '*/' -> channel(HIDDEN)
// ;
COMMENT        = _{ INLINE_COMMENT | LINE_COMMENT }
INLINE_COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// fragment ESC
// : '\\' ([`'\\/fnrt] | UNICODE)    // allow \`, \', \\, \/, \f, etc. and \uXXX
// ;
LINE_COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

// fragment UNICODE
// : 'u' HEX HEX HEX HEX
// ;
ESC = _{ "\\`" | "\\'" | "\\\\" | "\\/" | "\\f" | "\\n" | "\\r" | "\\t" | UNICODE_ESC }

// fragment HEX
// : [0-9a-fA-F]
// ;
UNICODE_ESC = @{ "\\u" ~ ASCII_HEX_DIGIT{4} }
